// Generated by CoffeeScript 1.10.0
'use strict';
var EventEmitter, NodeVM, VM, VMError, _compileToJS, cf, fs, pa, sb, ut, version, vm,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

version = process.versions.node.split('.');

if (parseInt(version[0]) < 6) {
  throw new Error("vm2 requires Node.js version 6 or newer (current version: " + process.versions.node + ")");
}

fs = require('fs');

vm = require('vm');

pa = require('path');

ut = require('util');

EventEmitter = require('events').EventEmitter;

sb = fs.readFileSync(__dirname + "/sandbox.js", "utf8");

cf = fs.readFileSync(__dirname + "/contextify.js", "utf8");

_compileToJS = function(code, compiler) {
  if ('function' === typeof compiler) {
    return compiler(code);
  }
  switch (compiler) {
    case 'coffeescript':
    case 'coffee-script':
    case 'cs':
    case 'text/coffeescript':
      return require('coffee-script').compile(code, {
        header: false,
        bare: true
      });
    case 'javascript':
    case 'java-script':
    case 'js':
    case 'text/javascript':
      return code;
    default:
      throw new VMError("Unsupported compiler '" + compiler + "'.");
  }
};


/*
Class VM.

@property {Boolean} running True if VM was initialized.
@property {Object} options VM options.
 */

VM = (function(superClass) {
  extend(VM, superClass);

  VM.prototype.options = null;


  /*
  	Create VM instance.
  	
  	@param {Object} [options] VM options.
  	@return {VM}
   */

  function VM(options) {
    var host, name, ref, ref1, ref2, ref3, value;
    if (options == null) {
      options = {};
    }
    this.options = {
      timeout: (ref = options.timeout) != null ? ref : void 0,
      sandbox: (ref1 = options.sandbox) != null ? ref1 : null,
      compiler: (ref2 = options.compiler) != null ? ref2 : 'javascript'
    };
    host = {
      String: String,
      Number: Number,
      Buffer: Buffer,
      Boolean: Boolean,
      Array: Array,
      Date: Date,
      Error: Error,
      RegExp: RegExp,
      Function: Function,
      Object: Object,
      VMError: VMError
    };
    this._context = vm.createContext(vm.runInNewContext("({})"));
    Reflect.defineProperty(this, '_internal', {
      value: vm.runInContext("(function(console, require, host) { " + cf + " \n})", this._context, {
        filename: "contextify.js",
        displayErrors: false
      }).call(this._context, console, require, host)
    });
    if (this.options.sandbox) {
      if (typeof this.options.sandbox !== 'object') {
        throw new VMError("Sandbox must be object");
      }
      ref3 = this.options.sandbox;
      for (name in ref3) {
        value = ref3[name];
        this._internal.contextify(value, {
          global: name
        });
      }
    }
  }


  /*
  	Run the code in VM.
  	
  	@param {String} code Code to run.
  	@return {*} Result of executed code.
   */

  VM.prototype.run = function(code) {
    var script;
    if (this.options.compiler !== 'javascript') {
      code = _compileToJS(code, this.options.compiler);
    }
    script = new vm.Script(code, {
      filename: "vm.js",
      displayErrors: false
    });
    return this._internal.decontextify(script.runInContext(this._context, {
      filename: "vm.js",
      displayErrors: false,
      timeout: this.options.timeout
    }));
  };

  return VM;

})(EventEmitter);


/*
Class NodeVM.

@property {Object} module Pointer to main module.
 */

NodeVM = (function(superClass) {
  extend(NodeVM, superClass);

  NodeVM.prototype._require = null;


  /*
  	Create NodeVM instance.
  	
  	Unlike VM, NodeVM lets you use require same way like in regular node.
  	
  	@param {Object} [options] VM options.
  	@return {NodeVM}
   */

  function NodeVM(options) {
    var closure, host, i, len, mdl, name, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, value;
    if (options == null) {
      options = {};
    }
    this.options = {
      sandbox: (ref = options.sandbox) != null ? ref : null,
      console: (ref1 = options.console) != null ? ref1 : 'inherit',
      require: (ref2 = options.require) != null ? ref2 : false,
      compiler: (ref3 = options.compiler) != null ? ref3 : 'javascript',
      require: (ref4 = options.require) != null ? ref4 : false
    };
    host = {
      require: require,
      process: process,
      console: console,
      setTimeout: setTimeout,
      setInterval: setInterval,
      setImmediate: setImmediate,
      clearTimeout: clearTimeout,
      clearInterval: clearInterval,
      clearImmediate: clearImmediate,
      String: String,
      Number: Number,
      Buffer: Buffer,
      Boolean: Boolean,
      Array: Array,
      Date: Date,
      Error: Error,
      RegExp: RegExp,
      Function: Function,
      Object: Object,
      VMError: VMError
    };
    this._context = vm.createContext(vm.runInNewContext("({})"));
    Object.defineProperty(this, '_internal', {
      value: vm.runInContext("(function(require, host) { " + cf + " \n})", this._context, {
        filename: "contextify.js",
        displayErrors: false
      }).call(this._context, require, host)
    });
    closure = vm.runInContext("(function (vm, host, contextify, decontextify) { " + sb + " \n})", this._context, {
      filename: "sandbox.js",
      displayErrors: false
    });
    Object.defineProperty(this, '_prepareRequire', {
      value: closure.call(this._context, this, host, this._internal.contextify, this._internal.decontextify)
    });
    if (this.options.sandbox) {
      if (typeof this.options.sandbox !== 'object') {
        throw new VMError("Sandbox must be object");
      }
      ref5 = this.options.sandbox;
      for (name in ref5) {
        value = ref5[name];
        this._internal.contextify(value, {
          global: name
        });
      }
    }
    if ((ref6 = this.options.require) != null ? ref6["import"] : void 0) {
      if (!Array.isArray(this.options.require["import"])) {
        this.options.require["import"] = [(ref7 = this.options.require) != null ? ref7["import"] : void 0];
      }
      ref9 = (ref8 = this.options.require) != null ? ref8["import"] : void 0;
      for (i = 0, len = ref9.length; i < len; i++) {
        mdl = ref9[i];
        this.require(mdl);
      }
    }
    this;
  }


  /*
  	Securely call method in VM. All arguments except functions are cloned during the process to prevent context leak. Functions are wrapped to secure closures. 
  	
  	Buffers are copied!
  	
  	IMPORTANT: Method doesn't check for circular objects! If you send circular structure as an argument, you process will stuck in infinite loop.
  	
  	@param {Function} method Method to execute.
  	@param {...*} args Arguments.
  	@return {*} Return value of executed method.
  	@deprecated
   */

  NodeVM.prototype.call = function() {
    var args, method;
    method = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (typeof method === 'function') {
      return method.apply(args);
    } else {
      throw new VMError("Unrecognized method type");
    }
  };


  /*
  	Require a module in VM and return it's exports.
   */

  NodeVM.prototype.require = function(module) {
    return this.run("module.exports = require('" + module + "');", 'vm.js');
  };


  /*
  	Run the code in NodeVM. 
  	
  	First time you run this method, code is executed same way like in node's regular `require` - it's executed with `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.
  	
  	@param {String} code Code to run.
  	@param {String} [filename] Filename that shows up in any stack traces produced from this script.
  	@return {*} Result of executed code.
   */

  NodeVM.prototype.run = function(code, filename) {
    var closure, dirname, module, script;
    if (this.options.compiler !== 'javascript') {
      code = _compileToJS(code, this.options.compiler);
    }
    if (filename) {
      filename = pa.resolve(filename);
      dirname = pa.dirname(filename);
    } else {
      filename = null;
      dirname = null;
    }
    module = vm.runInContext("({exports: {}})", this._context, {
      displayErrors: false
    });
    script = new vm.Script("(function (exports, require, module, __filename, __dirname) { " + code + " \n})", {
      filename: filename != null ? filename : "vm.js",
      displayErrors: false
    });
    closure = script.runInContext(this._context, {
      filename: filename != null ? filename : "vm.js",
      displayErrors: false
    });
    closure.call(this._context, module.exports, this._prepareRequire(dirname), module, filename, dirname);
    return this._internal.decontextify(module.exports);
  };


  /*
  	Create NodeVM and run code inside it.
  	
  	@param {String} script Javascript code.
  	@param {String} [filename] File name (used in stack traces only).
  	@param {Object} [options] VM options.
  	@return {NodeVM} VM.
   */

  NodeVM.code = function(script, filename, options) {
    var _vm;
    if (filename != null) {
      if (typeof filename === 'object') {
        options = filename;
        filename = null;
      } else if (typeof filename === 'string') {
        filename = pa.resolve(filename);
      } else {
        console.log(arguments);
        throw new VMError("Invalid arguments");
      }
    }
    if (arguments.length > 3) {
      throw new VMError("Invalid number of arguments");
    }
    _vm = new NodeVM(options);
    _vm.run(script, filename);
    return _vm;
  };


  /*
  	Create NodeVM and run script from file inside it.
  	
  	@param {String} [filename] File name (used in stack traces only).
  	@param {Object} [options] VM options.
  	@return {NodeVM} VM.
   */

  NodeVM.file = function(filename, options) {
    var _vm;
    _vm = new NodeVM(options);
    filename = pa.resolve(filename);
    if (!fs.existsSync(filename)) {
      throw new VMError("Script '" + filename + "' not found");
    }
    if (fs.statSync(filename).isDirectory()) {
      throw new VMError("Script must be file, got directory");
    }
    _vm.run(fs.readFileSync(filename, 'utf8'), filename);
    return _vm;
  };

  return NodeVM;

})(VM);


/*
VMError.

@param {String} message Error message.

@class
@extends {Error}
@property {String} stack Call stack.
@property {String} message Error message.
 */

VMError = (function(superClass) {
  extend(VMError, superClass);

  function VMError(message) {
    this.name = this.constructor.name;
    this.message = message;
    VMError.__super__.constructor.call(this);
    Error.captureStackTrace(this, this.constructor);
  }

  return VMError;

})(Error);

module.exports.VM = VM;

module.exports.NodeVM = NodeVM;

module.exports.VMError = VMError;
