// Generated by CoffeeScript 1.10.0
var NATIVE_MODULES, Script, fakeHandlers, noop,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

Script = host.require('vm').Script;

noop = function() {};

fakeHandlers = {};

NATIVE_MODULES = host.process.binding('natives');


/*
@param {Object} host Hosts's internal objects.
 */

return (function(_this) {
  return function(vm, host) {
    'use strict';
    var CACHE, EXTENSIONS, NATIVES, _prepareRequire, _requireNative, _resolveFilename, fs, global, pa;
    global = _this;
    NATIVES = {};
    CACHE = {};
    EXTENSIONS = {
      ".json": function(module, filename) {
        return module.exports = JSON.parse(fs.readFileSync(filename, "utf8"));
      }
    };

    /*
    	Resolve filename.
     */
    _resolveFilename = function(path) {
      var error, ex, exists, isdir, pkg;
      path = pa.resolve(path);
      exists = fs.existsSync(path);
      isdir = exists ? fs.statSync(path).isDirectory() : false;
      if (exists && !isdir) {
        return path;
      }
      if (fs.existsSync(path + ".js")) {
        return path + ".js";
      }
      if (fs.existsSync(path + ".json")) {
        return path + ".json";
      }
      if (fs.existsSync(path + "/package.json")) {
        try {
          pkg = JSON.parse(fs.readFileSync(path + "/package.json", "utf8"));
          if (pkg.main == null) {
            pkg.main = "index.js";
          }
        } catch (error) {
          ex = error;
          throw new VMError("Module '" + modulename + "' has invalid package.json", "EMODULEINVALID");
        }
        return _resolveFilename(path + "/" + pkg.main);
      }
      if (fs.existsSync(path + "/index.js")) {
        return path + "/index.js";
      }
      return null;
    };

    /*
    	Native require.
     */
    _requireNative = function(modulename) {
      var module, ref, script;
      if (Array.isArray(vm.options.require["native"])) {
        if (indexOf.call(vm.options.require["native"], '*') >= 0) {
          if (ref = "-" + modulename, indexOf.call(vm.options.require["native"], ref) >= 0) {
            throw new VMError("Access denied to require '" + modulename + "'", "EDENIED");
          }
        } else if (indexOf.call(vm.options.require["native"], modulename) < 0) {
          throw new VMError("Access denied to require '" + modulename + "'", "EDENIED");
        }
      } else if (vm.options.require["native"]) {
        if (!vm.options.require["native"][modulename]) {
          throw new VMError("Access denied to require '" + modulename + "'", "EDENIED");
        }
      } else {
        throw new VMError("Access denied to require '" + modulename + "'", "EDENIED");
      }
      if (NATIVES[modulename]) {
        return NATIVES[modulename].exports;
      }
      if (modulename === 'buffer') {
        return {
          Buffer: Buffer
        };
      }
      if (modulename === 'events') {
        script = new Script("(function (exports, require, module, process) { 'use strict'; " + NATIVE_MODULES[modulename] + " \n});", {
          filename: modulename + ".sb.js"
        });
        NATIVES[modulename] = module = {
          exports: {},
          require: _requireNative
        };
        script.runInContext(global)(module.exports, module.require, module, host.process);
        return module.exports;
      }
      return contextify(host.require(modulename), {
        readonly: true
      });
    };

    /*
    	Prepare require.
     */
    _prepareRequire = function(current_dirname) {
      var _require;
      _require = function(modulename) {
        var closure, code, dirname, error, error1, ex, extname, filename, module, path, paths, requiredPath, script;
        if (!vm.options.require) {
          throw new VMError("Access denied to require '" + modulename + "'", "EDENIED");
        }
        if (modulename == null) {
          throw new VMError("Module '' not found.", "ENOTFOUND");
        }
        if (typeof modulename !== 'string') {
          throw new VMError("Invalid module name '" + modulename + "'", "EINVALIDNAME");
        }
        if (NATIVE_MODULES[modulename]) {
          return _requireNative(modulename);
        }
        if (!vm.options.require.external) {
          throw new VMError("Access denied to require '" + modulename + "'", "EDENIED");
        }
        if (/^(\.|\.\/|\.\.\/)/.exec(modulename)) {
          if (!current_dirname) {
            throw new VMError("You must specify script path to load relative modules.", "ENOPATH");
          }
          filename = _resolveFilename(current_dirname + "/" + modulename);
        } else if (/^(\/|\\|[a-zA-Z]:\\)/.exec(modulename)) {
          filename = _resolveFilename(modulename);
        } else {
          if (!current_dirname) {
            throw new VMError("You must specify script path to load relative modules.", "ENOPATH");
          }
          paths = current_dirname.split(pa.sep);
          while (paths.length) {
            path = paths.join(pa.sep);
            filename = _resolveFilename("" + path + pa.sep + "node_modules" + pa.sep + modulename);
            if (filename) {
              break;
            }
            paths.pop();
          }
        }
        if (!filename) {
          throw new VMError("Module '" + modulename + "' not found", "ENOTFOUND");
        }
        if (CACHE[filename]) {
          return CACHE[filename].exports;
        }
        dirname = pa.dirname(filename);
        extname = pa.extname(filename);
        if (vm.options.require.root) {
          requiredPath = pa.resolve(vm.options.require.root);
          if (dirname.indexOf(requiredPath) !== 0) {
            throw new VMError("Module '" + modulename + "' is not allowed to be required. The path is outside the border!", "EDENIED");
          }
        }
        CACHE[filename] = module = {
          filename: filename,
          exports: {},
          require: _prepareRequire(dirname)
        };
        if (EXTENSIONS[extname]) {
          try {
            EXTENSIONS[extname](module, filename);
            return module.exports;
          } catch (error) {
            ex = error;
            throw new VMError("Failed to load '" + filename + "': [" + ex.message + "]", "ELOADFAIL");
          }
        }
        try {
          code = "(function (exports, require, module, __filename, __dirname) { 'use strict'; " + (fs.readFileSync(filename, "utf8")) + " \n});";
        } catch (error1) {
          ex = error1;
          throw new VMError("Failed to load '" + filename + "': [" + ex.message + "]", "ELOADFAIL");
        }
        script = new Script(code, {
          filename: filename != null ? filename : "vm",
          displayErrors: false
        });
        closure = script.runInContext(global, {
          filename: filename != null ? filename : "vm",
          displayErrors: false
        });
        closure(module.exports, module.require, module, filename, dirname);
        return module.exports;
      };
      _require.cache = CACHE;
      _require.extensions = EXTENSIONS;
      return _require;
    };

    /*
    	Prepare sandbox.
     */
    global.setTimeout = function(callback) {
      var tmr;
      arguments[0] = function() {
        return callback.call(null);
      };
      tmr = host.setTimeout.apply(host, arguments);
      return {
        ref: function() {
          return tmr.ref();
        },
        unref: function() {
          return tmr.unref();
        }
      };
    };
    global.setInterval = function(callback) {
      arguments[0] = function() {
        return callback.call(null);
      };
      host.setInterval.apply(host, arguments);
      return {
        ref: function() {
          return tmr.ref();
        },
        unref: function() {
          return tmr.unref();
        }
      };
    };
    global.setImmediate = function(callback) {
      arguments[0] = function() {
        return callback.call(null);
      };
      host.setImmediate.apply(host, arguments);
      return {
        ref: function() {
          return tmr.ref();
        },
        unref: function() {
          return tmr.unref();
        }
      };
    };
    global.clearTimeout = function() {
      host.clearTimeout.apply(host, arguments);
      return null;
    };
    global.clearInterval = function() {
      host.clearInterval.apply(host, arguments);
      return null;
    };
    global.clearImmediate = function() {
      host.clearImmediate.apply(host, arguments);
      return null;
    };
    global.process = {
      argv: [],
      title: host.process.title,
      version: host.process.version,
      versions: contextify(host.process.versions),
      arch: host.process.arch,
      platform: host.process.platform,
      env: {},
      pid: host.process.pid,
      features: contextify(host.process.features),
      nextTick: function(callback) {
        return host.process.nextTick(function() {
          return callback.call(null);
        });
      },
      hrtime: function() {
        return host.process.hrtime();
      },
      cwd: function() {
        return host.process.cwd();
      },
      on: function(name, handler) {
        var fake;
        if (name !== 'beforeExit' && name !== 'exit') {
          throw new Error("Access denied to listen for '" + name + "' event.");
        }
        fake = function() {
          return handler.call(null);
        };
        if (fakeHandlers[name] == null) {
          fakeHandlers[name] = new Map();
        }
        fakeHandlers[name].set(handler, fake);
        host.process.on(name, fake);
        return this;
      },
      once: function(name, handler) {
        var fake, ref;
        if (name !== 'beforeExit' && name !== 'exit') {
          throw new Error("Access denied to listen for '" + name + "' event.");
        }
        if ((ref = fakeHandlers[name]) != null ? ref.has(handler) : void 0) {
          return this;
        }
        fake = function() {
          fakeHandlers[name]["delete"](handler);
          return handler.call(null);
        };
        if (fakeHandlers[name] == null) {
          fakeHandlers[name] = new Map();
        }
        fakeHandlers[name].set(handler, fake);
        host.process.once(name, fake);
        return this;
      },
      listeners: function(name) {
        var array;
        if (!fakeHandlers[name]) {
          return [];
        }
        array = [];
        fakeHandlers[name].forEach(function(value, key) {
          return array.push(key);
        });
        return array;
      },
      removeListener: function(name, handler) {
        var fake, ref;
        fake = (ref = fakeHandlers[name]) != null ? ref.get(handler) : void 0;
        if (fake == null) {
          return this;
        }
        fakeHandlers[name]["delete"](handler);
        host.process.removeListener(name, fake);
        return this;
      },
      umask: function() {
        if (arguments.length) {
          throw new Error("Access denied to set umask.");
        }
        return host.process.umask();
      }
    };
    if (vm.options.console === 'inherit') {
      global.console = contextify(host.console, {
        readonly: true
      });
    } else if (vm.options.console === 'redirect') {
      global.console = {
        log: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          vm.emit.apply(vm, ['console.log'].concat(slice.call(decontextify(args))));
          return null;
        },
        info: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          vm.emit.apply(vm, ['console.info'].concat(slice.call(decontextify(args))));
          return null;
        },
        warn: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          vm.emit.apply(vm, ['console.warn'].concat(slice.call(decontextify(args))));
          return null;
        },
        error: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          vm.emit.apply(vm, ['console.error'].concat(slice.call(decontextify(args))));
          return null;
        },
        dir: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          vm.emit.apply(vm, ['console.dir'].concat(slice.call(decontextify(args))));
          return null;
        },
        time: noop,
        timeEnd: noop,
        trace: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          vm.emit.apply(vm, ['console.trace'].concat(slice.call(decontextify(args))));
          return null;
        }
      };
    }
    fs = host.require('fs');
    pa = host.require('path');

    /*
    	Return contextized require.
     */
    return _prepareRequire;
  };
})(this)(vm, host);
